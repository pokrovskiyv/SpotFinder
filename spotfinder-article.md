# SpotFinder: Telegram-бот, который понимает "промочил ноги"

## Когда AI действительно помогает в реальной жизни

Представьте ситуацию: вы в незнакомом городе, начинается дождь, и вы понимаете, что обувь промокла насквозь. Телефон разряжается, времени разбираться в Google Maps нет. Нужно быстро найти магазин обуви. Вы открываете карты... и сталкиваетесь с десятками категорий: "Торговый центр", "Обувной магазин", "Спортивные товары", "Одежда и обувь". Какую выбрать? А может, просто поискать по названию? Но вы не знаете названий местных магазинов.

Это типичная проблема современных картографических сервисов. Они невероятно мощные, но требуют от пользователя точного знания того, что он ищет. Нужно выбрать правильную категорию, применить фильтры, разобраться в интерфейсе. 

А что если можно было бы просто написать: **"Промочил ноги"** — и получить список ближайших обувных магазинов?

Именно эту проблему решает SpotFinder — Telegram-бот, который понимает ваши потребности на естественном языке. Не категории, не фильтры, не "правильные" запросы. Просто опишите ситуацию, как рассказали бы другу.

**SpotFinder** — это serverless-приложение на базе Supabase Edge Functions, использующее Google Gemini Pro с технологией Maps Grounding. Бот понимает естественный язык, распознает неявные намерения и ведет осмысленные диалоги о местах вокруг вас. Весь код проекта открыт под лицензией MIT.

---

## Почему это интересно: революция Google Maps Grounding

Раньше создание подобного бота было сложной задачей. Нужно было построить два отдельных коннектора — один к языковой модели (чтобы понимать намерения), другой к картам (чтобы искать места). А между ними — написать сложную логику, которая превращает понимание AI в структурированные запросы к Maps API.

**Google Maps Grounding** кардинально меняет ситуацию. Теперь можно отправить один запрос к Gemini, и он уже "заземлен" (grounded) в реальные данные Google Maps. AI не просто "придумывает" места из своих знаний — он работает с актуальной информацией: адресами, отзывами, рейтингами, часами работы.

### "Магия" понимания контекста

SpotFinder понимает неявные запросы:

- **"Промочил ноги"** → обувные магазины поблизости
- **"Хочу поработать"** → кафе с Wi-Fi и тихой атмосферой
- **"Сел телефон"** → места с розетками рядом
- **"Заболел"** → ближайшая открытая аптека

Но особенно впечатляют **субъективные критерии**:

- **"Уютное кафе"** → бот анализирует отзывы про атмосферу, интерьер, освещение
- **"Романтичный ресторан"** → ищет места, подходящие для свиданий
- **"Тихое место для работы"** → проверяет упоминания о спокойствии и наличии розеток

Это не просто поиск по категории "кафе". Это анализ характеристик мест на основе реальных данных Google Maps.

### Контекстные диалоги

После получения результатов можно задавать уточняющие вопросы:

```
Пользователь: Найди ресторан
Бот: [показывает 3 ресторана]

Пользователь: А у второго есть парковка?
Бот: Да, в отзывах упоминают бесплатную парковку для посетителей.

Пользователь: Какой у первого рейтинг?
Бот: 4.7 звезд на основе 342 отзывов.
```

Бот "помнит" контекст диалога и понимает, о каком месте вы спрашиваете.

---

## Как это работает: архитектура изнутри

Давайте заглянем под капот. SpotFinder построен как serverless-приложение с четким разделением ответственности:

```
Пользователь → Telegram Bot API → Webhook → Orchestrator 
    ↓
SessionManager ← → Supabase (PostgreSQL + PostGIS)
    ↓
GeminiClient → Google Gemini + Maps Grounding
    ↓
Ответ → Telegram → Пользователь
```

### Ключевые компоненты

#### 1. Orchestrator: мозг системы

`Orchestrator` — это ядро бизнес-логики. Он получает каждое сообщение от пользователя и принимает решения:

- Это новый пользователь? → Приветствие и запрос геолокации
- Это геолокация? → Сохранить в сессию
- Это текстовый запрос? → Проверить наличие геолокации, отправить в Gemini
- Это уточняющий вопрос? → Извлечь контекст предыдущих результатов

Orchestrator также управляет всем потоком данных, форматированием сообщений и отслеживанием действий пользователя.

```typescript
async processUpdate(update: TelegramUpdate): Promise<void> {
  if (update.message) {
    await this.handleMessage(update.message);
  } else if (update.callback_query) {
    await this.handleCallbackQuery(update.callback_query);
  }
}
```

#### 2. SessionManager: память бота

Главная проблема всех Telegram-ботов — **отсутствие состояния** (stateless nature). HTTP-запросы не "помнят" друг друга. 

`SessionManager` решает эту проблему, сохраняя контекст в PostgreSQL:

```typescript
{
  user_id: 123456789,
  location: { lat: 55.7558, lon: 37.6173 },
  location_updated_at: "2025-10-28T10:30:00Z",
  last_query: "уютное кафе",
  last_results: [
    { place_id: "ChIJ...", name: "Кофе и Книги" },
    { place_id: "ChIJ...", name: "Уютный уголок" }
  ],
  conversation_context: [/* история диалога */]
}
```

**TTL (Time-to-Live) для геолокации**: 20 минут. Если пользователь отправил локацию час назад, а сейчас в другом месте, бот вежливо попросит обновить местоположение.

Это позволяет боту понимать фразы типа "а третий вариант?" или "как туда дойти?" — он знает, о каких местах идет речь.

#### 3. GeminiClient: промпт-инженерия в действии

`GeminiClient` — это не просто обертка над API. Это модуль, который превращает запросы пользователя в структурированные промпты для AI.

**Плохо:**
```
"Найди уютное кафе"
```

**Хорошо:**
```
SYSTEM: Ты — гиперлокальный ассистент для поиска мест. 
Пользователь находится в координатах {55.7558, 37.6173}.
Используй Google Maps data для поиска. Анализируй отзывы 
для субъективных критериев ("уютное", "романтичное").

USER: Найди уютное кафе поблизости
```

Gemini получает четкий контекст и инструкции, что значительно улучшает качество ответов.

#### 4. Google Maps Grounding: "заземление" в реальность

Ключевая особенность — Gemini не просто генерирует текст. Он работает с реальными данными:

- Получает список мест от Google Maps API
- Анализирует их отзывы, рейтинги, фото
- Сопоставляет с запросом пользователя
- Возвращает **структурированные данные**: Place IDs, координаты, адреса

Благодаря этому SpotFinder может создавать интерактивные кнопки:
- 🗺 Показать на карте
- 🚶 Построить маршрут
- ⭐ Посмотреть отзывы

### Технологический стек

- **Backend**: Supabase Edge Functions (Deno runtime + TypeScript)
- **Database**: PostgreSQL 15 с расширением PostGIS для геопространственных запросов
- **AI**: Google Gemini Pro с Maps Grounding
- **Messaging**: Telegram Bot API (webhook)
- **Кэш и сессии**: PostgreSQL таблицы

---

## Интересные технические вызовы

Разработка SpotFinder была полна нетривиальных задач. Вот самые интересные.

### Challenge 1: Управление геолокацией

**Проблема:** Пользователь мог отправить геолокацию час назад, а сейчас находится в совершенно другом месте. Если бот будет искать места рядом со старой локацией — это плохой UX.

**Решение:** Каждая геолокация в сессии имеет TTL (Time-to-Live) — 20 минут. Если данные устарели, бот отправляет вежливое сообщение:

```
⏰ Твоя геолокация устарела (прошло более 20 минут).
Чтобы я мог искать места рядом, пожалуйста, поделись 
своим текущим местоположением 👇
```

И добавляет кнопку Telegram для быстрой отправки локации.

### Challenge 2: Контекстные уточнения

**Проблема:** Как понять запрос "А у второго есть парковка?", если это уже третье сообщение в диалоге?

**Решение:** Двухкомпонентная система:

1. **SessionManager** сохраняет `last_results` — массив мест из предыдущего поиска
2. **ContextHandler** распознает ссылки на эти результаты:

```typescript
extractOrdinal(text: string): number | null {
  // "у второго" → 2
  // "первый вариант" → 1
  // "третье место" → 3
}
```

Когда пользователь пишет "у второго есть парковка?", бот:
1. Понимает, что это уточнение (не новый поиск)
2. Извлекает индекс: 2
3. Берет Place ID второго места из `last_results`
4. Делает целевой запрос к Gemini уже с конкретным Place ID

### Challenge 3: Оптимизация затрат на API

**Проблема:** Каждый запрос к Gemini API стоит денег. При 1000 активных пользователей это может быть ~$210/месяц.

**Решение:** Трехуровневое кэширование в PostgreSQL:

| Тип данных | TTL | Таблица | Зачем |
|-----------|-----|---------|-------|
| Результаты поиска | 4 часа | `search_results_cache` | Частые запросы ("кафе рядом") |
| Детали мест | 24 часа | `places_cache` | Информация о конкретных местах |
| Геокодинг городов | permanent | `geocoding_cache` | Координаты не меняются |

**Результат:** Снижение нагрузки на API **до 40%**. Для проекта с 1000 пользователей это экономия ~$84/месяц.

```sql
-- Проверка кэша перед реальным запросом
SELECT * FROM places_cache 
WHERE place_id = $1 
  AND updated_at > NOW() - INTERVAL '24 hours';
```

### Challenge 4: Аналитика и мониторинг

**Проблема:** Как понять, какие места популярны? Сколько стоит каждый пользователь? Когда оптимизировать промпты?

**Решение:** Недавно добавлена комплексная система отслеживания:

**Таблица `user_actions`:**
```sql
CREATE TABLE user_actions (
  action_id UUID PRIMARY KEY,
  user_id BIGINT REFERENCES users(user_id),
  action_type VARCHAR(50), -- 'view_reviews', 'click_maps', 'select_place'
  place_id TEXT,
  search_id UUID REFERENCES search_history(search_id),
  metadata JSONB,
  created_at TIMESTAMP DEFAULT NOW()
);
```

**Таблица `api_cost_metrics`:**
```sql
CREATE TABLE api_cost_metrics (
  metric_id UUID PRIMARY KEY,
  user_id BIGINT,
  api_provider VARCHAR(50), -- 'gemini', 'google_maps'
  api_type VARCHAR(100),
  cost_usd DECIMAL(10, 6),
  from_cache BOOLEAN DEFAULT false,
  quota_exceeded BOOLEAN DEFAULT false,
  date DATE DEFAULT CURRENT_DATE,
  created_at TIMESTAMP DEFAULT NOW()
);
```

Теперь можно отвечать на вопросы:
- Какие места пользователи выбирают чаще всего?
- Сколько запросов каждый пользователь делает в день?
- Какой процент запросов обрабатывается из кэша?
- Насколько эффективны наши промпты?

---

## От идеи к MVP: путь разработки

### Структурированный подход

Разработка началась не с кода, а с **Product Requirements Document (PRD)**. В нем была определена мета-модель развития AI-ассистента:

**3 уровня эволюции:**
1. **Справочник** (Реактивный) — отвечает на прямые вопросы
2. **Консультант** (Проактивный) — понимает намерения, дает рекомендации
3. **Планировщик** (Ассистент) — строит сложные маршруты, оптимизирует

MVP сфокусирован на **Уровне 2 (Консультант)** — именно здесь появляется настоящая ценность AI.

### Что вошло в MVP

**Функциональность:**
- 5 основных категорий мест (еда, аптеки, финансы, магазины, развлечения)
- Понимание 10+ типичных неявных запросов
- Контекстные диалоги до 3 уровней вложенности
- Базовая персонализация (dietary restrictions)

**Метрики успеха:**
- **Accuracy**: 80%+ понимания запросов ✅
- **Response Time**: <5 секунд для 90% запросов ✅
- **Success Rate**: 75%+ успешных поисков ✅

**Код:**
- ~35 файлов
- ~3,500 строк TypeScript
- 9 SQL миграций для базы данных
- ~5,000 слов документации

**Тесты:**
- Unit тесты для core логики (`*_test.ts`)
- Integration тесты для API
- Mock тесты для внешних сервисов
- Deno test runner

Структура позволяет легко добавлять новые компоненты и масштабировать функциональность.

---

## Что дальше: roadmap проекта

### v1.1 — Оптимизация (в процессе)

✅ **Завершено:**
- Система аналитики и кэширования
- API cost tracking с лимитами
- Полное отслеживание действий пользователей

⏳ **В работе:**
- A/B тестирование промптов
- Analytics dashboard для визуализации данных
- Улучшенная персонализация на основе истории

### v2.0 — Транзакции (планируется)

Следующий большой шаг — переход от "найти место" к "забронировать место":

- **Бронирование столиков** через интеграцию с OpenTable или прямые API ресторанов
- **Интеграция с такси** (Uber API, Yandex.Taxi)
- **Premium подписка** ($2.99/мес):
  - Unlimited запросы
  - Приоритетный поиск
  - Расширенная персонализация
  - Сохраненные места (избранное)
- **Онлайн оплата** через Telegram Payments

### v3.0 — Планировщик (будущее)

Самый амбициозный уровень — умение строить сложные маршруты:

**Мультишаговое планирование:**
```
Пользователь: Мне нужно в аптеку, потом в химчистку 
и за продуктами

Бот: Я построил оптимальный маршрут:
1. Аптека "36.6" (открыта, 5 мин пешком)
2. Химчистка "Блеск" (закрывается через час!)
3. Супермаркет "Зеленый" (круглосуточно)

Общее время: ~35 минут
[Показать на карте] [Начать навигацию]
```

**Дополнительно:**
- Оптимизация маршрутов (TSP алгоритм)
- Групповые поездки (встреча в удобной точке)
- ML для предиктивных рекомендаций
- Голосовой ввод/вывод

---

## Выводы: что я узнал, создавая SpotFinder

### Технические инсайты

**1. AI + Maps Grounding меняет правила игры**

Раньше создание location-based AI ассистента требовало месяцев работы. Сейчас — недель. Google Maps Grounding снимает огромный пласт инфраструктурной работы.

**2. Serverless архитектура — идеальна для MVP**

Supabase Edge Functions позволили развернуть бота без настройки серверов, балансировщиков, мониторинга. Просто пишешь TypeScript код и деплоишь.

**3. Промпт-инженерия критична**

Качество ответов AI на 80% зависит от качества промпта. Нужно явно описывать роль, контекст, ожидаемый формат ответа.

**Пример системного промпта:**
```typescript
const systemPrompt = `
Ты — гиперлокальный AI-ассистент для поиска мест.
Используй Google Maps data для актуальной информации.

Правила:
1. Анализируй отзывы для субъективных критериев
2. Учитывай время суток и день недели
3. Предлагай 2-3 варианта, не перегружай пользователя
4. Возвращай Place IDs для интеграции с Maps

Пользователь находится в: {lat}, {lon}
Текущее время: {time}
`;
```

**4. Управление состоянием — главный вызов в ботах**

HTTP stateless, но диалог stateful. SessionManager стал одним из самых сложных компонентов, хотя концептуально простой.

**5. Кэширование окупается**

40% снижение нагрузки на API → $84/мес экономии для 1000 пользователей → окупает хостинг БД в 4 раза.

**6. TTL для геолокации критичен для UX**

Первая версия не имела TTL — пользователи получали результаты для мест, где были час назад. После добавления TTL (20 мин) — жалоб не было.

**7. Структурированные данные от Gemini открывают возможности**

Place IDs позволяют не просто показывать текст, а создавать rich UI:
- Интерактивные кнопки
- Построение маршрутов
- Интеграция с Telegram Maps

---

## Open Source и вклад в сообщество

SpotFinder — полностью **открытый проект** под лицензией **MIT**.

**Что вы найдете в репозитории:**

📖 **Документация:**
- `README.md` — обзор проекта с примерами
- `QUICKSTART.md` — развертывание за 15 минут
- `DEPLOYMENT.md` — полное руководство для продакшена
- `TESTING.md` — как запустить тесты
- `CONTRIBUTING.md` — гайд для контрибьюторов
- `docs/Architecture.md` — детали архитектуры

💻 **Код:**
- Полный исходный код на TypeScript
- 9 готовых SQL миграций
- Unit и integration тесты
- Примеры конфигураций

🚀 **Готовность к deployment:**
- Скрипты для автоматической настройки webhook
- Docker support (опционально)
- Переменные окружения через `.env`
- Один клик deploy на Supabase

---

## Попробуйте сами

Хотите запустить своего AI-ассистента для поиска мест?

**Быстрый старт (15 минут):**

1. **Клонируйте репозиторий:**
```bash
git clone https://github.com/your-username/spotfinder.git
cd spotfinder
```

2. **Настройте Supabase:**
```bash
# Создайте проект на supabase.com
# Примените миграции
supabase db push
```

3. **Получите API ключи:**
- Telegram Bot Token: [@BotFather](https://t.me/BotFather)
- Google Gemini API: [ai.google.dev](https://ai.google.dev)
- Google Maps API: [console.cloud.google.com](https://console.cloud.google.com)

4. **Разверните функции:**
```bash
npm run deploy
npm run webhook:setup
```

**Готово!** Бот работает.

---

## Заключение

SpotFinder — это эксперимент на стыке AI, геопространственных данных и UX. Проект показывает, как современные технологии (Gemini, Maps Grounding, serverless) позволяют создавать решения, которые еще год назад требовали бы команды разработчиков и месяцев работы.

**Ключевые takeaways:**
- AI реально полезен, когда "заземлен" в актуальные данные
- Serverless снижает барьер входа для сложных проектов
- Управление состоянием — критично для conversational UI
- Промпт-инженерия — это навык, который стоит развивать
- Кэширование и мониторинг окупаются с первого дня

Проект активно развивается. Если вам интересна тема AI + Maps, буду рад вашему фидбеку, идеям или даже контрибьюшенам в код.

---

**Автор:** Виталий Покровский  
**GitHub:** [github.com/your-repo/spotfinder](https://github.com)  
**Email:** pokrovskiy.v@gmail.com  
**Telegram:** [@v_pokrovskiy](https://t.me/v_pokrovskiy)

---

*Статья написана 28 октября 2025 года. SpotFinder v1.1 с системой аналитики и кэширования.*

